### The "Anchor-Based" Flow Visualized

1. **User Query** -> **Vector Search** -> Finds **Top 3 Chunks** (The "Anchors").
2. **Identify Entities:** Who is mentioned in these chunks? (e.g., Anchor Chunk A mentions "Field Editor").
3. **Graph Expansion (Depth Search):** What is related to these entities? (e.g., "Field Editor" -> `CONFIGURES` -> "Validation Rule").
4. **Source Retrieval:** Fetch the text for the "Validation Rule" (The "Neighbor").
5. **Aggregate:** Combine Anchor Text + Neighbor Text -> **LLM Context**.

---

### **Updated US-007: Anchor-Based Graph Retrieval**

**Description:** Implement retrieval logic that uses Vector Search as the "Entry Point" into the graph, then expands to find contextually related documentation.

**Tasks:**

#### **Step A: Vector Search (The Entry Point)**

**Goal:** Find the most relevant documentation chunks using standard semantic search.
**Implementation:**

* **API:** `vector_store.similarity_search(query, k=5)`
* **Result:** A list of `Anchor Chunks`.

#### **Step B: Anchor & Expand (The Graph Layer)**

**Goal:** Use the entities found in the Anchor Chunks to discover *related* concepts that the vector search might have missed.
**Implementation:**

* **Input:** List of `chunk_id`s from Step A.
* **Cypher Query:**
```cypher
// 1. Start from the Anchor Chunks found by Vector Search
UNWIND $anchor_chunk_ids AS chunk_id
MATCH (anchor:Chunk {id: chunk_id})

// 2. Find Entities mentioned in these chunks (The Anchors)
MATCH (anchor)<-[:MENTIONED_IN]-(entity:Entity)

// 3. Expand 1 Hop to find Neighbors
//    (e.g., Field Editor -> CONFIGURES -> Validation Rule)
MATCH (entity)-[:CONFIGURES|DEPENDS_ON|MAPPED_TO]-(neighbor:Entity)

// 4. Pruning (God Node Protection)
//    Check how generic the neighbor is (degree check)
MATCH (neighbor)-[:MENTIONED_IN]->(n_docs:Chunk)
WITH neighbor, count(n_docs) as degree
WHERE degree <= 20  // Skip generic nodes like "Configuration"

// 5. Return unique Neighbor IDs
RETURN collect(DISTINCT neighbor.id) as neighbor_ids

```



#### **Step C: Neighbor Source Retrieval**

**Goal:** Get the full text for the related concepts found in Step B.
**Implementation:**

* **Input:** `neighbor_ids` from Step B.
* **Logic:**
* For every specific neighbor (e.g., "Validation Rule"), we need its definition.
* **Query:** `MATCH (e:Entity {id: $id})-[:MENTIONED_IN]->(c:Chunk) ...`
* **Safety:** Use Vector Similarity to pick the top 3 chunks for that neighbor (same as before).


* **Output:** A list of `Neighbor Chunks`.

#### **Step D: Context Assembly**

**Goal:** Combine everything for the LLM.
**Implementation:**

* **Context:** `Anchor Chunks` (Direct Hits) + `Neighbor Chunks` (Graph Context).
* **Prompt:**
```text
USER QUERY: {query}

--- DIRECT DOCUMENTATION ---
{anchor_text}

--- RELATED CONTEXT ---
{neighbor_text}

Please answer the question using the direct documentation. 
Use the related context to explain connections if necessary.

```



**Acceptance Criteria:**
        
* [ ] **Relevance:** Searching for "Field Editor" pulls in "Validation Rule" text automatically because the graph links them.
* [ ] **Pruning:** Generic neighbors (degree > 10) are ignored.