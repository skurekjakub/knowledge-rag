<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Data caching</title>
</head>
<body>
<p>The Xperience API allows developers to cache data in website code. We recommend caching any frequent API calls that load significant data from the Xperience database (or other external sources). For example, caching is typically a good idea when <a href="/documentation/developers-and-admins/api/content-item-api">retrieving content in the code of your sites</a>.</p>

<div>

</div>
<div>
<p>The <code>IContentRetriever</code> <a href="#caching-content-retrieval-in-web-app-contexts">API</a> provides implicit caching for content retrieval operations. This removes the need to manually wrap data retrieval logic in a caching service, which simplifies your code.</p>
</div>

<p>To cache data, the system provides the <code>CMS.Helpers.IProgressiveCache</code> service.</p>
<p>The service supports <strong>sliding expiration</strong> (cache duration is refreshed upon successive requests for the same item), and <strong>progressive caching</strong> (parallel caching requests from multiple threads don’t result in redundant database operations; instead, one thread is used to fetch the data, which is then shared with other waiting threads). Use the following methods to cache data:</p>
<ul>
<li>
<code>Load</code> – loads data using a delegate method and caches the results.</li>
<li>
<code>LoadAsync</code> – an equivalent of the <code>Load</code> method for loading and caching data in asynchronous code.</li>
</ul>
<p>An instance of the service can be obtained using <a href="/documentation/developers-and-admins/development/website-development-basics/dependency-injection">dependency injection</a>.</p>
<p>See the following sections for examples of usage:</p>
<ul>
<li><a href="#cache-reusable-content-items-and-pages">Cache content items</a></li>
<li><a href="#cache-general-objects">Cache general objects</a></li>
</ul>
<h2 id="cache-reusable-content-items-and-pages">Cache reusable content items and pages</h2>
<p>The following example demonstrates the usage of <code>IProgressiveCache</code> to cache a content item retrieval operation on article <a href="/documentation/business-users/website-content">pages</a>. Assumes content type model classes generated by the <a href="/documentation/developers-and-admins/api/generate-code-files-for-system-objects">code file generator</a>.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Content item caching example</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

using CMS.ContentEngine;
using CMS.DataEngine;

// ...

// Instances of services for caching and content retrieval obtained via dependency injection
private readonly IContentQueryExecutor executor;
private readonly IProgressiveCache progressiveCache;

public async Task&lt;IEnumerable&lt;ArticlePage&gt;&gt; GetArticles(int topN = 0, CancellationToken cancellationToken = default)
{
    // Caches the loaded data
    return await progressiveCache.LoadAsync(async (cacheSettings) =&gt;
    {
        // Gets the data to cache
        var articles = (await GetAllArticles(topN, cancellationToken)).ToList();

        // Configures cache dependencies for the data. See 'Set cache dependencies'
        cacheSettings.CacheDependency = await GetCacheDependency(articles);

        return articles;
    },
    // Configures cache behavior and generates the cache key for the entry
    new CacheSettings(cacheMinutes: 5,
                      useSlidingExpiration: true,
                      cacheItemNameParts: new[] { "MyWebsiteChannel", nameof(GetArticles), "/Articles", topN.ToString() }));
}

// Gets all articles according to the provided parameterization using content item query
private Task&lt;IEnumerable&lt;ArticlePage&gt;&gt; GetAllArticles(int topN, CancellationToken cancellationToken)
{
    return executor
            .GetMappedWebPageResult&lt;ArticlePage&gt;(
                new ContentItemQueryBuilder()
                    .ForContentType(ArticlePage.CONTENT_TYPE_NAME,
                                config =&gt; config
                                    .WithLinkedItems(
                                                maxLevel: 1,
                                                options =&gt; options.IncludeWebPageData())
                                    .TopN(topN)
                                    .OrderBy(OrderByColumn.Desc(nameof(ArticlePage.ArticlePagePublishDate)))
                                    .ForWebsite("MyWebsiteChannel",
                                        pathMatch: PathMatch.Children("/Articles"))
                                    ), cancellationToken: cancellationToken);
}

</code></pre>
</div>

<p>The example caches the retrieved pages and ensures the following <a href="#cachesettings">cache behavior</a>:</p>
<ul>
<li>
<strong>Duration:</strong> 5 minutes</li>
<li>
<strong>Cache key:</strong> MyWebsiteChannel|GetArticles|/Articles|&lt;topN&gt;</li>
<li>
<strong>Sliding expiration:</strong> true</li>
</ul>
<h3 id="set-cache-dependencies">Set cache dependencies</h3>
<p>Correctly configuring <a href="/documentation/developers-and-admins/development/caching/cache-dependencies">cache dependencies</a> is a critical part of building effective caching solutions. Cache dependencies inform the system whenever the source data of a cached entity changes and prompt it to revoke the corresponding cache entry. This is especially important in richly-linked <a href="/guides/architecture/content-modeling/content-modeling-guide">content models</a> with many dependencies between various content types, where any change to linked content items must clear the cache as well.</p>
<p>Building upon the caching example above, assume the article object being retrieved is modeled like so:</p>
<p></p>
<p>Then the following snippet shows a sample implementation of the <code>GetCacheDependency</code> method that creates dependencies on the retrieved articles as well as their linked items. The example uses <code>CacheDependencyBuilder</code> to create dependencies on the retrieved pages and <code>IWebPageLinkedItemsDependencyAsyncRetriever</code> to generate dependency cache keys for all linked content items of the page up to the specified depth. See <a href="/documentation/developers-and-admins/development/caching/cache-dependencies">Cache dependencies</a> and <a href="#cache-dependencies-on-linked-content-items">Cache dependencies on linked content items</a> for details about the respective APIs.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Building cache dependencies</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

using System;
using System.Linq;
using System.Collections.Generic;

using CMS.Websites;
using CMS.Helpers;

using Kentico.Content.Web.Mvc;

// ...

// Instances of services obtained via dependency injection
private readonly IWebPageLinkedItemsDependencyAsyncRetriever linkedItemsDependencyRetriever;
private readonly ICacheDependencyBuilderFactor dependencyBuilderFactory;

public async Task&lt;CMSCacheDependency&gt; GetCacheDependency(IEnumerable&lt;ArticlePage&gt; articles)
{
    // Builds a cache key for each linked content item associated with the articles,
    // up to the depth of 1 (first-level references). The generated keys ensure 
    // the cache is cleared when linked items are modified.
    IEnumerable&lt;string&gt; linkedItemsCacheKeys =
        (await linkedItemsDependencyAsyncRetriever
                .Get(articles.Select(article =&gt; article.SystemFields.ContentItemID), maxLevel: 1));

    // Creates an instance of 'CacheDependencyBuilder'
    CacheDependencyBuilder cacheDependencyBuilder = dependencyBuilderFactory.Create();

    // Adds cache dependencies on each page in the collection using their content tree path
    CMSCacheDependency cacheDependency = cacheDependencyBuilder
        .ForWebPageItems()
            .ByPathWithChannelContext(GetPaths(articles))
            .Builder()
        .AddDependency(linkedItemsCacheKeys)
        .Build();

    return cacheDependency;
}

private async IEnumerable&lt;CacheDependencyPath&gt; GetPaths(IEnumerable&lt;ArticlePage&gt; articles)
{
    return articles.Select(article =&gt; CacheDependencyPath.Single(article.SystemFields.WebPageItemTreePath));
}

</code></pre>
</div>

<h3 id="cache-dependencies-on-linked-content-items">Cache dependencies on linked content items</h3>
<p>For content items composed of multiple linked items, it may be required to trigger a cache refresh when not only the main object but also any of its linked items change. </p>
<p>To generate cache dependencies on linked items, use:</p>
<ul>
<li>
<code>CMS.ContentEngine.ILinkedItemsDependencyAsyncRetriever</code> – for reusable content items.</li>
<li>
<code>CMS.WebPages.IWebPageLinkedItemsDependencyAsyncRetriever</code> – for web pages.</li>
</ul>
<p>Both services contain <code>Get</code> methods that generate the dependencies based on content item identifiers and their content type definition. For example:</p>
<ul>
<li><code>contentitem|byid|&lt;contentItemId&gt;</code></li>
<li><code>cms.contenttype|byname|&lt;contentTypeCodeName&gt;</code></li>
</ul>
<p>See <a href="#set-cache-dependencies">Set cache dependencies</a> for an example of usage.</p>
<h3 id="preview-mode-and-caching">Preview mode and caching</h3>
<p>We strongly suggest disabling caching for preview mode in order to prevent cache bloat. You can check whether the current request is under preview mode via <code>IWebsiteChannelContext.IsPreview</code>. For example, you can create a helper method that you can use together with <code>CacheSettings.Cached</code>.</p>
<p><a href="#caching-content-retrieval-in-web-app-contexts">ContentRetriever API</a> automatically detects preview mode and disables caching accordingly when retrieving content, preventing cache bloat without additional configuration.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Caching and preview</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

using CMS.Helpers;
using CMS.Websites.Routing;

// ...

private bool IsCacheEnabled()
{
    // An instance of IWebsiteChannelContext can be retrieved using dependency injection
    return !websiteChannelContext.IsPreview;
}

// ...

await progressiveCache.LoadAsync(async (cacheSettings) =&gt;
{
    // Do not use the cache if under preview (e.g., when previewing pages in a channel)
    cacheSettings.Cached = IsCacheEnabled();

    // ...
)},
// Configures cache behavior and generates the cache key for the entry
new CacheSettings(cacheMinutes: 10, cacheItemNameParts: "cacheKeyName");

</code></pre>
</div>

<h2 id="caching-content-retrieval-in-web-app-contexts">Caching content retrieval in web app contexts</h2>
<p>The <code>IContentRetriever</code> <a href="/documentation/developers-and-admins/api/content-item-api/content-retriever-api">API</a> supports implicit caching for retrieval operations. This functionality is equivalent to wrapping the retrieval operation in a <code>IProgressiveCache</code> delegate, ensuring efficient caching and retrieval of data.</p>
<p>When you use the <code>IContentRetriever</code> API, caching is automatically applied unless explicitly disabled using <code>RetrievalCacheSettings.CacheDisabled</code>. The caching mechanism automatically:</p>
<ul>
<li>
<strong>Caches results</strong> – Automatically stores the results of retrieval operations in the cache.</li>
<li>
<strong>Sets up cache dependencies</strong> – Ensures that cached data is invalidated when the underlying content changes.</li>
<li>
<strong>Supports sliding expiration</strong> – Refreshes the cache duration upon successive requests for the same item, if enabled.</li>
</ul>
<p>The following example demonstrates how implicit caching works in the <code>IContentRetriever</code> API:</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Set up caching with IContentRetriever</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre data-line="3-8,14"><code>
// Configure cache settings with a 30-minute expiration and sliding expiration enabled.
var cacheSettings = new RetrievalCacheSettings(
    // Add a unique suffix to identify the cached data.
    cacheItemNameSuffix: $"{nameof(ContentTypesQueryParameters.OfContentType)}|ArticleGenerated",
    // Cache entries will expire 30 minutes after their last access.
    cacheExpiration: TimeSpan.FromMinutes(30),
    // Resets the expiration timer on each access to keep frequently accessed items in the cache.
    useSlidingExpiration: true);

// Retrieve the current page of type 'ArticleGenerated' using the configured cache settings.
var result = await contentRetriever.RetrieveCurrentPage&lt;ArticleGenerated&gt;(
    RetrieveCurrentPageParameters.Default,
    RetrieveCurrentPageQueryParameters.Default,
    cacheSettings
);

</code></pre>
</div>

<p>This is functionally similar to manually wrapping the retrieval operation in a <code>IProgressiveCache</code> delegate, but with the added benefit of being seamlessly integrated into the API.</p>
<h2 id="cache-general-objects">Cache general objects</h2>
<p>The following code example shows how to synchronously load and cache user data from the database using <code>IProgressiveCache.Load</code>.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong></strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

using CMS.DataEngine;
using CMS.Helpers;
using CMS.Membership;

// ...

// Instances of services used for data retrieval and caching (e.g., obtained using dependency injection)
private readonly IUserInfoProvider userInfoProvider;
private readonly IProgressiveCache progressiveCache;
private readonly ICacheDependencyBuilderFactory dependencyBuilderFactory;

// Caches the data for 10 minutes under the cache key "customdatasource|users"
// Automatically checks whether the given key is already in the cache 
ObjectQuery&lt;UserInfo&gt; data = progressiveCache
    .Load(cs =&gt; LoadUsers(cs), new CacheSettings(cacheMinutes: 10,
                                                 cacheItemNameParts: "customdatasource|users"));

// Loads the required data. Called only if the data doesn't already exist in the cache.
private ObjectQuery&lt;UserInfo&gt; LoadUsers(CacheSettings cs)
{
    // Loads all user objects from the database
    ObjectQuery&lt;UserInfo&gt; result = UserInfo.Provider.Get();

    // Creates an instance of 'CacheDependencyBuilder'
    CacheDependencyBuilder dependencyBuilder = dependencyBuilderFactory.Create();

    // Sets a cache dependency for the data
    // The data is removed from the cache if the objects represented by
    // the dependency are modified (administration user objects in this case)
    cacheSettings.CacheDependency = dependencyBuilder
        .ForInfoObjects&lt;UserInfo&gt;()
            .All()
            .Builder()
        .Build();

    return result;
}

</code></pre>
</div>

<p>The caching logic checks if the key specified by the <code>CacheSettings</code> object is in the cache:</p>
<ul>
<li>If yes, the method directly loads the data from the cache.</li>
<li>If not, the code calls the method specified by the delegate parameter (<code>LoadUsers</code> in the example) with the <code>CacheSettings</code> as a parameter. The method loads the data from the database, sets a cache dependency, and saves the key into the cache for the specified number of minutes.</li>
</ul>
<p>You can use the caching API when handling data anywhere in your code.</p>
<h3 id="asynchronous-caching-example">Asynchronous caching example</h3>
<p>The following code example shows how to asynchronously load and cache user data from the database using <code>IProgressiveCache.LoadAsync</code>.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong></strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

using System;
using System.Threading.Tasks;

using CMS.Helpers;

// Instances of services used for data retrieval and caching (e.g., obtained using dependency injection)
private readonly IUserInfoProvider userInfoProvider;
private readonly IProgressiveCache progressiveCache;
private readonly ICacheDependencyBuilderFactory dependencyBuilderFactory;

// Asynchronously loads data and ensures caching
var data = await progressiveCache.LoadAsync(async cacheSettings =&gt;
{
    // Calls an async method that loads the required data (implementation not included in the example)
    var result = await LoadUsersAsync();

    // Creates an instance of 'CacheDependencyBuilder'
    CacheDependencyBuilder dependencyBuilder = dependencyBuilderFactory.Create();

    // Creates a cache dependency on all administration users in the system
    cacheSettings.CacheDependency = dependencyBuilder
        .ForInfoObjects&lt;UserInfo&gt;()
            .All()
            .Builder()
        .Build();

    return result;
}, new CacheSettings(cacheMinutes: TimeSpan.FromMinutes(10).TotalMinutes,
                     cacheItemNameParts: "customdatasource|users"));

</code></pre>
</div>

<h3 id="using-distributed-cache-providers">Using distributed cache providers</h3>
<p>Xperience by Kentico currently does not support distributed cache instead of its native in-memory cache. You can use distributed cache for your custom objects, but not for native Xperience objects.</p>
<h2 id="cachesettings">CacheSettings</h2>
<p>When using <code>IProgressiveCache</code> caching methods, you need to provide <code>CMS.Helpers.CacheSettings</code> as a parameter. The settings configure the cache key that stores the data. If you set the same cache key name for multiple data loading operations, they share the same cached value.</p>
<p>You can work with the following properties of the <code>CacheSettings</code>:</p>

<table>
<thead>
<tr>
<td>
<p>CacheSettings property</p>
</td>
<td>
<p>Type</p>
</td>
<td>
<p>Description</p>
</td>
</tr>
</thead>
<tr>
<td>
<p>CacheMinutes</p>
</td>
<td>
<p>int</p>
</td>
<td>
<p>The number of minutes for which the cache stores the loaded data. The default value is 10 minutes.</p>
<p>We recommend using an interval of 1 to 60 minutes.</p>
</td>
</tr>
<tr>
<td>
<p>CacheDependency</p>
</td>
<td>
<p>CMSCacheDependency</p>
</td>
<td>
<p>Sets <a href="/documentation/developers-and-admins/development/caching/cache-dependencies">dependencies</a> for the cache key (use <a href="/documentation/developers-and-admins/development/caching/cache-dependencies">CacheDependencyBuilder</a> to get the dependency object).</p>
<p>Make sure you always set cache dependencies, unless the <code>CacheMinutes</code> interval is set to an extremely short time or the cached content is predominantly static.</p>
</td>
</tr>
<tr>
<td>
<p>BoolCondition</p>
</td>
<td>
<p>bool</p>
</td>
<td>
<p>A boolean condition that must evaluate to <code>true</code> for the data to be cached.</p>
</td>
</tr>
<tr>
<td>
<p>Cached</p>
</td>
<td>
<p>bool</p>
</td>
<td>
<p>Indicates whether the data should be cached (based on <code>CacheMinutes</code> and <code>BoolCondition</code>).</p>
</td>
</tr>
<tr>
<td>
<p>AllowProgressiveCaching</p>
</td>
<td>
<p>bool</p>
</td>
<td>
<p>Enables or disables progressive caching, which ensures that multiple threads accessing the same data only load it once and reuse the result.</p>
</td>
</tr>
</table>

<h3 id="icontentretriever-cache-settings">IContentRetriever cache settings</h3>
<p>When using <a href="/documentation/developers-and-admins/api/content-item-api/content-retriever-api">ContentRetriever API</a>, you can configure the cache settings using the <code>RetrievalCacheSettings</code> class. See <a href="/documentation/developers-and-admins/api/content-item-api/content-retriever-api#implicit-result-caching">ContentRetriever API</a> for details.</p>

</body>
</html>
